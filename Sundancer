#!/usr/bin/env python3

# ghetto IPSW patcher, or I'd rather even say *merger*

import os
import time
import shutil
import zipfile
import tarfile
import tempfile
import plistlib
import argparse
import subprocess
from pathlib import Path
from dataclasses import dataclass

# ===================== patch config =====================

# XXX move all this to a separate entity?
# Will have to do it anyway when we support more combos

HOODOO_IBSS_IV = "e803340e5c0ac2d1c898f6980285e67e"
HOODOO_IBSS_KEY = "406b5d2678c9292cf3c5af199ba962aa23db115a9d7160fa1bd09fd9932160d9"

HOODOO_IBSS_PATCHES = {
    # Image3 signature check
    0x50C4 : bytes.fromhex("00 20 18 60")
}

HOODOO_IBEC_IV = "a160c55d4571b060bb82689e2f10d4ef"
HOODOO_IBEC_KEY = "457d910bc7fd0ef6b71d2714d20d9a70cbc741e863ae57883dba4568d29912d4"

HOODOO_KERNELCACHE_IV = "5d618983129f3b121ad032dc0a170ea9"
HOODOO_KERNELCACHE_KEY = "835138e000a3d9425cc1d0d57cacd55ea6a7e46a42fac59dd55f98cb80240fe3"

HOODOO_DEVICETREE_IV = "f5596138fe9a0d428648309504bcc130"
HOODOO_DEVICETREE_KEY = "55f81e535541c1dcbdfa6eae4361cffa1c8930d79e40c98d5c1de27fd16946c8"

HOODOO_IBEC_PATCHES = {
    # Image3 signature check
    0x11944 : bytes.fromhex("00 20 18 60"),

    # debug-enabled
    0x11F48 : bytes.fromhex("01 20 01 20"),

    # boot-args injection
    0x12E68 : bytes.fromhex("38 C4 F2 4F 38 C4 F2 4F"),

    # boot-args
    0x2C438 : b"rd=md0 nand-enable-reformat=1 -progress amfi=0xff serial=3\0",

    # allow any var in `setenv`
    0xF0F4 : bytes.fromhex("00 BF")
}

HOODOO_ROOT_FS_KEY = "33148831d924a6ea1e9f1051cb0abfb15dc481a91617f37d950612de185c5f182d963a15"

HOODOO_ROOT_FS_FILES = [
    "/usr/share/firmware/multitouch/Common.mtprops",
    "/usr/share/firmware/multitouch/iPod.mtprops",
    "/usr/share/firmware/wifi/4329b1/n18.bin",
    "/usr/share/firmware/wifi/4329b1/n18.txt"
]

HOODOO_BLUETOOTH_FW_NAME = "BCM4329B1_002.002.023.0965.0967_N18_090611.hcd"
HOODOO_BLUETOOL_FW_OFF = 0x9E810
HOODOO_BLUETOOL_FW_LEN = 0x4346

SUNDANCE_ROOT_FS_KEY = "9b80f46bffd90f2507fd1978df3d72e933ac0f894b8ff13aca73f2ef6b822186a4075236"

SUNDANCE_DSC_PATCHES = {
    # getDeviceVariant() => CFSTR("A")
    0x7C71A88: bytes.fromhex("47 F6 14 00 C0 F2 A8 20 78 44 70 47"),

    # Product ID
    0x7C77D70: bytes.fromhex("15 27"),

    # page 31857 new hash
    0xE39E9D2: bytes.fromhex("dbe3d106732b6f8ce73e72293b80633efdf7414e"),

    # page 31863 new hash
    0xE39EA4A: bytes.fromhex("439b458669a3fd901a655985694e3f57c258a24a")
}

SUNDANCE_LAUNCH_DAEMONS_TO_UNLIMIT = [
    "/System/Library/LaunchDaemons/com.apple.absinthed.N88.plist",
    "/System/Library/LaunchDaemons/com.apple.fairplayd.N88.plist",
    "/System/Library/LaunchDaemons/com.apple.securekeyvaultd.N88.plist"
]

SUNDANCE_RAMDISK_IV = "404e344acc3ab148a3d90997f00aa308"
SUNDANCE_RAMDISK_KEY = "96bbec672f7c5533250f4fa14798647031b5913843d00d8a4c9b6ebec0664f55"

SUNDANCE_ASR_PATCHES = {
    # Image signature check
    0x12EC8: bytes.fromhex("F2 E7"),

    # page 19 new hash
    0x2BF62: bytes.fromhex("1e7b497288ea86b9dda5e8d5a88e72dcb44d5e73")
}

SUNDANCE_RAMDISK_SIZE = 16 * 1024 * 1024

# ===================== debug logging =====================

NONE   = ""
DIM    = "\u001b[2m"
RESET  = "\u001b[0m"

start_time = 0.0
_verbose = False

def _debug_init(verbose: bool):
    global start_time, _verbose
    start_time = time.time()   
    _verbose = verbose

def _log(color, args, kwargs):
    print(color + "|%7.3f |  " % (time.time() - start_time), end="")
    print(*args, **kwargs, end=RESET+"\n")

def log(*args, **kwargs):
    _log(NONE, args, kwargs)

def debug(*args, **kwargs):
    if _verbose:
        _log(DIM, args, kwargs)

# ================== subprocess wrappers ==================

def _run(exec: Path, args: "list[str]", env: dict = None):
    subprocess.run([exec] + args, env=env, check=True, stdout=subprocess.DEVNULL)

def image3_decrypt(src: Path, dest: Path, iv: str, key: str, keep_cont: bool = False):
    args = [str(src), str(dest), "-iv", str(iv), "-k", str(key)]

    if keep_cont:
        args += ["-decrypt"]

    _run(
        SCRIPT_ROOT / "executables" / "xpwntool",
        args
    )

    debug("decrypted Image3 at %s to %s" % (src.name, dest.name))

def image3_create(src: Path, dest: Path, template: Path):
    _run(
        SCRIPT_ROOT / "executables" / "xpwntool",
        [str(src), str(dest), "-t", str(template)]
    )

    debug("created Image3 at %s from %s with template %s" % (dest.name, src.name, template.name))

def dmg_extract(src: Path, dest: Path, key: str):
    _run(
        SCRIPT_ROOT / "executables" / "dmg",
        ["extract", str(src), str(dest), "-k", key]
    )

    debug("decrypted DMG at %s to %s" % (src.name, dest.name))

def dmg_build(src: Path, dest: Path):
    _run(
        SCRIPT_ROOT / "executables" / "dmg",
        ["build", str(src), str(dest)]
    )

    debug("built DMG at %s to %s" % (src.name, dest.name))

def hfsplus_grow(dmg: Path, size: int):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "grow", str(size)]
    )

    debug("grown HFS+ image at %s to %d bytes" % (dmg.name, size))

def hfsplus_extract(dmg: Path, src: str, dest: Path):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "extract", src, str(dest)]
    )

    debug("extracted %s to %s from HFS+ image at %s" % (src, dest.name, dmg.name))

def hfsplus_replace(dmg: Path, src: Path, dest: str, uid: int = 0, gid: int = 0, mode: int = 0o644):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "rm", dest]
    )

    hfsplus_add(dmg, src, dest, uid, gid, mode)

def hfsplus_add(dmg: Path, src: Path, dest: str, uid: int = 0, gid: int = 0, mode: int = 0o644):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "add", str(src), dest]
    )

    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "chown", "%d:%d" % (uid, gid), dest]
    )

    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "chmod", "%o" % (mode), dest]
    )

    debug("added %s in HFS+ image at %s to %s" % (src.name, dmg.name, dest))

def hfsplus_rm(dmg: Path, path: str):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "rm", path]
    )

    debug("removed %s from HFS+ image at %s" % (path, dmg.name))

def hfsplus_rmdir(dmg: Path, dir: str):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "rmall", dir]
    )

    debug("removed %s folder from HFS+ image at %s" % (dir, dmg.name))

def hfsplus_mv(dmg: Path, src: str, dest: str):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "mv", src, dest]
    )

    debug("moved %s to %s in HFS+ image at %s" % (src, dest, dmg.name))

def hfsplus_untar(dmg: Path, tar: Path, dest: str):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "untar", str(tar), dest]
    )

    debug("untar'd %s to %s in HFS+ image at %s" % (tar.name, dest, dmg.name))

# ===================== IPSW parsing =====================

class BuildIdentity:
    def __init__(self, raw: dict):
        self.raw = raw
        self.chip_id = raw["ApChipID"]
        self.board_id = raw["ApBoardID"]
        self.device = raw["Info"]["DeviceClass"]
        self.restore_behavior = raw["Info"]["RestoreBehavior"]
        self.build_train = raw["Info"]["BuildTrain"]
        self.components = { k:v["Info"]["Path"] for k,v in raw["Manifest"].items() }

        debug("loaded build identity for %s (%s)" % (self.device, self.restore_behavior))

class BuildManifest:
    def __init__(self, data: bytes):
        self.raw = plistlib.loads(data)
        self.version = self.raw["ProductVersion"]
        self.build = self.raw["ProductBuildVersion"]
        self.identities = list()

        for i in self.raw["BuildIdentities"]:
            self.identities.append(BuildIdentity(i))

        debug("loaded build manifest for iOS %s (%s)" % (self.version, self.build))

    def find_identity(self, device: str, behavior: str) -> BuildIdentity:
        return next(filter(
            lambda x: x.device == device and x.restore_behavior == behavior,
            self.identities)
        )

class IPSW:
    def __init__(self, path: Path):
        self.path = path
        self._zip = zipfile.ZipFile(path)

        raw_manifest = self.read_file("BuildManifest.plist")
        self.manifest = BuildManifest(raw_manifest)

        debug("loaded IPSW")

    def read_file(self, path: str) -> bytes:
        return self._zip.read(path)
    
    def extract_file(self, src: str, dest: str):
        with self._zip.open(src, "r") as zf:
            with open(dest, "wb") as f:
                shutil.copyfileobj(zf, f)

def extract_comp(comp: str, dest_dir: Path, ipsw: IPSW, build_identity: BuildIdentity) -> str:
    path = build_identity.components[comp]
    name = os.path.basename(path)
    ipsw.extract_file(path, dest_dir / name)

    debug("extracted component %s from IPSW at %s" % (comp, ipsw.path))

    return name

# ====================== main logic ======================

@dataclass
class AddFile:
    src: Path
    dest: str
    uid: int = 0
    gid: int = 0
    mode: int = 0o644

def _add_misc_files() -> "list[AddFile]":
    return [
        AddFile(
            RESOURCES_ROOT / "N18AP.plist",
            "/System/Library/CoreServices/SpringBoard.app/N18AP.plist"
        ),
        AddFile(
            RESOURCES_ROOT / "8784ae8d7066b0f0136be91dcfe632a436ffd6fb.boot.script",
            "/private/etc/bluetool/8784ae8d7066b0f0136be91dcfe632a436ffd6fb.boot.script"
        ),
        AddFile(
            RESOURCES_ROOT / "8784ae8d7066b0f0136be91dcfe632a436ffd6fb.init.script",
            "/private/etc/bluetool/8784ae8d7066b0f0136be91dcfe632a436ffd6fb.init.script"
        ),
        AddFile(
            RESOURCES_ROOT / "8784ae8d7066b0f0136be91dcfe632a436ffd6fb.deepsleep.script",
            "/private/etc/bluetool/8784ae8d7066b0f0136be91dcfe632a436ffd6fb.deepsleep.script"
        )
    ]

def hoodoo_extract_firmwares(wd: Path, ipsw: IPSW, build_identity: BuildIdentity) -> "list[AddFile]":
    result = []

    log("extracting iOS 5 root filesystem")
    os_orig_path = wd / extract_comp("OS", wd, ipsw, build_identity)
    os_raw_path = os_orig_path.with_name("HoodooOS.dmg")

    dmg_extract(os_orig_path, os_raw_path, HOODOO_ROOT_FS_KEY)
    os_orig_path.unlink()

    log("extracting WLAN & multitouch firmwares")

    for f in HOODOO_ROOT_FS_FILES:
        hfsplus_extract(os_raw_path, f, wd / os.path.basename(f))
        result.append(AddFile(
            wd / os.path.basename(f),
            f
        ))

    log("extracting Bluetooth firmware")

    bluetool_path = wd / "BlueTool"
    hfsplus_extract(os_raw_path, "/usr/sbin/BlueTool", bluetool_path)

    with open(bluetool_path, "rb") as f:
        f.seek(HOODOO_BLUETOOL_FW_OFF)
        bluetooth_fw = f.read(HOODOO_BLUETOOL_FW_LEN)

    bluetool_path.unlink()

    bluetooth_fw_path = wd / HOODOO_BLUETOOTH_FW_NAME
    with open(bluetooth_fw_path, "wb") as f:
        f.write(bluetooth_fw)

    result.append(AddFile(
        bluetooth_fw_path,
        "/private/etc/bluetool/" + HOODOO_BLUETOOTH_FW_NAME
    ))

    os_raw_path.unlink()

    return result

def patch_binary(src: Path, dest: Path, patches: dict):
    try:
        shutil.copyfile(src, dest)
    except shutil.SameFileError:
        pass

    with open(dest, "r+b") as f:
        for o,v in patches.items():
            f.seek(o)
            f.write(v)

def hoodoo_replace_comp(comp: str, iv: str, key: str, src: Path, wd: Path, ipsw: IPSW, build_identity: BuildIdentity) -> str:
    path = wd / extract_comp(comp, wd, ipsw, build_identity)

    decrypted_path = path.with_suffix(".decrypted")
    image3_decrypt(path, decrypted_path, iv, key, keep_cont=True)
    path.unlink()

    image3_create(src, wd / comp, decrypted_path)
    decrypted_path.unlink()

    return comp

def hoodoo_process_iboots(wd: Path, ipsw: IPSW, build_identity: BuildIdentity) -> "list[str]":
    result = {}

    # LLB
    result["LLB"] = extract_comp("LLB", wd, ipsw, build_identity)

    # iBoot
    result["iBoot"] = extract_comp("iBoot", wd, ipsw, build_identity)
    
    def patch_image3(src: Path, dest: Path, iv: str, key: str, patches: dict):
        raw_path = src.with_suffix(".raw")
        image3_decrypt(src, raw_path, iv, key)

        patched_path = src.with_suffix(".patched")
        patch_binary(raw_path, patched_path, patches)
        raw_path.unlink()

        template_path = src.with_suffix(".template")
        shutil.copyfile(src, template_path)
        image3_create(patched_path, dest, template_path)
        patched_path.unlink()
        template_path.unlink()

    # iBSS
    ibss_name = extract_comp("iBSS", wd, ipsw, build_identity)
    ibss_orig_path = wd / ibss_name
    patch_image3(ibss_orig_path, ibss_orig_path, HOODOO_IBSS_IV, HOODOO_IBSS_KEY, HOODOO_IBSS_PATCHES)
    result["iBSS"] = ibss_name

    # iBEC
    ibec_name = extract_comp("iBEC", wd, ipsw, build_identity)
    ibec_orig_path = wd / ibec_name
    patch_image3(ibec_orig_path, ibec_orig_path, HOODOO_IBEC_IV, HOODOO_IBEC_KEY, HOODOO_IBEC_PATCHES)
    result["iBEC"] = ibec_name

    return result

def _unlimit_launch_daemon(wd: Path, dmg_path: Path, launch_daemon: str):
    log("unlimiting %s LaunchDaemon" % os.path.basename(launch_daemon))

    plist_tmp_path = wd / "launch_daemon.plist"
    hfsplus_extract(dmg_path, launch_daemon, plist_tmp_path)

    with open(plist_tmp_path, "rb") as f:
        plist = plistlib.load(f)
        del plist["LimitLoadToHardware"]

    with open(plist_tmp_path, "wb") as f:
        plistlib.dump(plist, f, fmt=plistlib.FMT_XML)

    hfsplus_replace(dmg_path, plist_tmp_path, launch_daemon)
    plist_tmp_path.unlink()

def sundance_process_root_filesystem(wd: Path, ipsw: IPSW, build_identity: BuildIdentity, to_add: "list[AddFile]") -> str:
    log("extracting iOS 6 root filesystem")

    os_orig_path = wd / extract_comp("OS", wd, ipsw, build_identity)
    os_raw_path = os_orig_path.with_name("SundanceOS.dmg")

    dmg_extract(os_orig_path, os_raw_path, SUNDANCE_ROOT_FS_KEY)
    os_orig_path.unlink()

    log("removing OTA update files")
    hfsplus_rmdir(os_raw_path, "/usr/standalone/update")

    log("patching dyld shared cache")

    dsc_tmp_path = wd / "dsc"
    hfsplus_extract(os_raw_path, "/System/Library/Caches/com.apple.dyld/dyld_shared_cache_armv7", dsc_tmp_path)
    patch_binary(dsc_tmp_path, dsc_tmp_path, SUNDANCE_DSC_PATCHES)
    hfsplus_replace(os_raw_path, dsc_tmp_path, "/System/Library/Caches/com.apple.dyld/dyld_shared_cache_armv7", mode=0o755)
    dsc_tmp_path.unlink()

    for ld in SUNDANCE_LAUNCH_DAEMONS_TO_UNLIMIT:
        _unlimit_launch_daemon(wd, os_raw_path, ld)

    # `hfsplus` messes up if we create already existing folders/files,
    # `hfsplus` messes up if add files to non-existing folders,
    # so we use tarball extraction capability that handles all that well
    tar_path = wd / "files.tar"
    tar = tarfile.open(tar_path, "x", format=tarfile.GNU_FORMAT)

    already_there = set()

    for a in to_add:
        p = ""

        # `hfsplus` needs explicit entries for directories
        comps = str(Path(a.dest).parent).split("/")
        for c in comps:
            if not c:
                continue

            p += c + "/"

            if p not in already_there:
                inf = tarfile.TarInfo(p)
                inf.type = tarfile.DIRTYPE
                inf.uid = 0
                inf.gid = 0
                inf.mode = 0o755

                tar.addfile(inf)

                already_there.add(p)

        inf = tarfile.TarInfo(a.dest[1:])
        inf.type = tarfile.REGTYPE
        inf.size = os.stat(a.src).st_size
        inf.uid = a.uid
        inf.gid = a.gid
        inf.mode = a.mode

        with open(a.src, "rb") as f:
            tar.addfile(inf, f)

        debug("added %s to temporary tarball" % a.dest)

    tar.close()
    hfsplus_untar(os_raw_path, tar_path, "/")
    tar_path.unlink()

    # breaks everything, unfortunately
    # hfsplus_mv(os_raw_path, "/", "/%s%s.N18OS" % (build_identity.build_train, ipsw.manifest.build))

    log("packaging iOS 6 root filesystem")
    os_dest = "SundanceOSN18.dmg"
    dmg_build(os_raw_path, wd / os_dest)
    os_raw_path.unlink()

    return os_dest

def sundance_process_ramdisk(wd: Path, ipsw: IPSW, build_identity: BuildIdentity) -> str:
    log("extracting iOS 6 ramdisk")

    rd_orig_path = wd / extract_comp("RestoreRamDisk", wd, ipsw, build_identity)
    rd_raw_path = rd_orig_path.with_name("SundanceRamdisk.dmg")

    image3_decrypt(rd_orig_path, rd_raw_path, SUNDANCE_RAMDISK_IV, SUNDANCE_RAMDISK_KEY)

    log("growing ramdisk")
    hfsplus_grow(rd_raw_path, SUNDANCE_RAMDISK_SIZE)

    log("patching ASR")
    asr_tmp_path = wd / "asr"
    hfsplus_extract(rd_raw_path, "/usr/sbin/asr", asr_tmp_path)
    patch_binary(asr_tmp_path, asr_tmp_path, SUNDANCE_ASR_PATCHES)
    hfsplus_replace(rd_raw_path, asr_tmp_path, "/usr/sbin/asr", mode=0o755)
    asr_tmp_path.unlink()

    log("replacing rc.boot")
    hfsplus_replace(rd_raw_path, SCRIPT_ROOT / "rc_boot" / "rc.boot", "/etc/rc.boot", mode=0o755)

    log("putting exploit.dmg")
    hfsplus_add(rd_raw_path, SCRIPT_ROOT / "exploit" / "exploit.dmg", "/exploit.dmg")

    log("moving options plist")
    hfsplus_mv(rd_raw_path, "/usr/local/share/restore/options.n88.plist", "/usr/local/share/restore/options.n18.plist")

    log("packaging iOS 6 ramdisk")
    rd_dest = "SundanceRamdiskPatched.img3"
    image3_create(rd_raw_path, wd / rd_dest, rd_orig_path)

    rd_orig_path.unlink()
    rd_raw_path.unlink()

    return rd_dest

def assemble_bundle(
    wd: Path,
    hoodoo_ipsw: IPSW,
    hoodoo_identity: BuildIdentity,
    sundance_ipsw: IPSW,
    patched_comps: dict,
    output: Path
):
    log("assembling bundle")

    output.mkdir()

    raw_identity = hoodoo_identity.raw.copy()
    raw_identity["Info"]["BuildNumber"] = sundance_ipsw.manifest.build
    raw_identity["Info"]["BuildTrain"] = "Sundance"

    for k,v in raw_identity["Manifest"].items():
        comp_path = v["Info"]["Path"]
        comp_parent = os.path.dirname(comp_path)

        comp_parent_dest = output / comp_parent
        comp_parent_dest.mkdir(exist_ok=True, parents=True)

        comp_dest = comp_parent_dest / os.path.basename(comp_path)

        if k in patched_comps:
            if comp_dest.exists():
                comp_dest.unlink()
            shutil.copyfile(wd / patched_comps[k], comp_dest)
        else:
            hoodoo_ipsw.extract_file(comp_path, comp_dest)

    raw_manifest = hoodoo_ipsw.manifest.raw.copy()
    raw_manifest["ProductBuildVersion"] = sundance_ipsw.manifest.build
    raw_manifest["ProductVersion"] = sundance_ipsw.manifest.version
    raw_manifest["BuildIdentities"] = [raw_identity]

    with open(output / "BuildManifest.plist", "wb") as f:
        plistlib.dump(raw_manifest, f, fmt=plistlib.FMT_XML)
        log("wrote BuildManifest")

def process(args):
    hoodoo_ipsw = IPSW(args.hoodoo)
    hoodoo_identity = hoodoo_ipsw.manifest.find_identity("n18ap", "Erase")

    sundance_ipsw = IPSW(args.sundance)
    sundance_identity = sundance_ipsw.manifest.find_identity("n88ap", "Erase")

    with tempfile.TemporaryDirectory() as wd:
        wd = Path(wd)

        patched_comps = {}

        log("processing iOS 5 iBoots")
        patched_comps.update(hoodoo_process_iboots(wd, hoodoo_ipsw, hoodoo_identity))

        log("packaging kernelcache")
        patched_comps["KernelCache"] = patched_comps["RestoreKernelCache"] = hoodoo_replace_comp("KernelCache", HOODOO_KERNELCACHE_IV, HOODOO_KERNELCACHE_KEY, args.kernel, wd, hoodoo_ipsw, hoodoo_identity)

        log("packaging DeviceTree")
        patched_comps["DeviceTree"] = patched_comps["RestoreDeviceTree"] = hoodoo_replace_comp("DeviceTree", HOODOO_DEVICETREE_IV, HOODOO_DEVICETREE_KEY, args.devicetree, wd, hoodoo_ipsw, hoodoo_identity)

        add_files = []
        add_files += hoodoo_extract_firmwares(wd, hoodoo_ipsw, hoodoo_identity)
        add_files += _add_misc_files()

        patched_comps["OS"] = sundance_process_root_filesystem(wd, sundance_ipsw, sundance_identity, add_files)
        patched_comps["RestoreRamDisk"] = sundance_process_ramdisk(wd, sundance_ipsw, sundance_identity)

        assemble_bundle(
            wd,
            hoodoo_ipsw,
            hoodoo_identity,
            sundance_ipsw,
            patched_comps,
            args.output
        )

SCRIPT_ROOT = Path(__file__).parent
RESOURCES_ROOT = Path(__file__).parent / "resources"
DEFAULT_KERNEL = SCRIPT_ROOT / "artifacts" / "kernelcache.n18ap.bin"
DEFAULT_DEVICE_TREE = SCRIPT_ROOT / "artifacts" / "DeviceTree.n18ap.bin"

def main():
    parser = argparse.ArgumentParser(description="convert iPod touch 3 iOS 5.1.1 IPSW to iOS 6.0")
    parser.add_argument("hoodoo", type=Path, help="path to iPod touch 3 5.1.1 (9B206) IPSW")
    parser.add_argument("sundance", type=Path, help="path to iPhone 3GS 6.0 (10A403) IPSW")
    parser.add_argument("output", type=Path, help="output IPSW to flash")
    parser.add_argument(
        "-k", "--kernel",
        type=Path,
        default=DEFAULT_KERNEL,
        help="path to kernel, default - " + str(DEFAULT_KERNEL.relative_to(SCRIPT_ROOT))
    )
    parser.add_argument(
        "-d", "--devicetree",
        type=Path,
        default=DEFAULT_DEVICE_TREE,
        help="path to DeviceTree, default - " + str(DEFAULT_DEVICE_TREE.relative_to(SCRIPT_ROOT))
    )
    parser.add_argument("-v", "--verbose", action="store_true", help="verbose logging")

    args = parser.parse_args()

    _debug_init(args.verbose)

    if not args.hoodoo.exists():
        print("iPod touch 3 5.1.1 (9B206) IPSW does NOT exist")
        exit(-1)

    if not args.sundance.exists():
        print("iPhone 3GS 6.0 (10A403) IPSW does NOT exist")
        exit(-1)

    if not args.kernel.exists():
        print("kernelcache does NOT exist")
        exit(-1)

    if args.output.exists():
        print("output path already exists")
        exit(-1)

    process(args)

    log("DONE!")

if __name__ == "__main__":
    main()
