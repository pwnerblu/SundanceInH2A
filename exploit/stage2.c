#include "funcs.h"

#define THUMB_BX_LR         (0x4770)
#define THUMB_MOV_R0_1      (0x2001)
#define THUMB_MOV_R0_0      (0x2000)
#define THUMB_STR_R0_R3     (0x6018)

#define WRITE32(_addr, _val) \
    *(volatile uint32_t *)(_addr) = _val

#define WRITE16(_addr, _val) \
    *(volatile uint16_t *)(_addr) = _val

static
size_t _strlen(const char *str) {
    const char *curr = str;
    while (*curr) {
        curr++;
    }
    return curr - str;
}

__attribute__((naked))
void UpdateDeviceTree_tramp() {
    asm("ldr r0, 1f");
    asm("bx  r0");
    asm("1:");
    asm(".long _UpdateDeviceTree__hook");
}

static
void patches_apply() {
    /* patch Image3 signature checks */
    WRITE16(IMAGE3_PATCH, THUMB_MOV_R0_0);
    WRITE16(IMAGE3_PATCH + 2, THUMB_STR_R0_R3);

    /* debug-enabled patch */
    WRITE16(DEBUG_ENABLED_PATCH_ADDR1, THUMB_MOV_R0_1);
    WRITE16(DEBUG_ENABLED_PATCH_ADDR2, THUMB_MOV_R0_1);

    /* point boot args string to a new location */
    WRITE32(BOOT_ARGS_PATCH_ADDR1, BOOT_ARGS_NEW_ADDR);
    WRITE32(BOOT_ARGS_PATCH_ADDR2, BOOT_ARGS_NEW_ADDR);

    /* populate them from the env var */
    const char *boot_args = env_get("boot-args");
    if (!boot_args) {
        boot_args = "";
    }

    size_t boot_args_len = _strlen(boot_args);
    memcpy((void *)BOOT_ARGS_NEW_ADDR, boot_args, boot_args_len + 1);

    /* add "amfi=0xff" boot-arg if not already there */
    const char *amfi_arg = " amfi=0xff";
    if (boot_args_len == 0) {
        /* get rid of the space if boot-args string is empty */
        amfi_arg++;
    }

    if (!contains_boot_arg((const char *)BOOT_ARGS_NEW_ADDR, "amfi=", true)) {
        strlcat((char *)BOOT_ARGS_NEW_ADDR, amfi_arg, 512);
    }

    /* 
     * add "launchctl_enforce_codesign=0" boot-arg if not already there,
     * it disables signed LaunchDaemons cache on iOS 6.1.x,
     * and should be no-op on 6.0.x
     */
    const char *launchctl_arg = " launchctl_enforce_codesign=0";
    if (!contains_boot_arg((const char *)BOOT_ARGS_NEW_ADDR, "launchctl_enforce_codesign=", true)) {
        strlcat((char *)BOOT_ARGS_NEW_ADDR, launchctl_arg, 512);
    }

    /* apply UpdateDeviceTree hook */
    void *tramp = (void *)((uintptr_t)UpdateDeviceTree_tramp & ~1); // clear the Thumb bit
    memcpy((void *)UPDATE_DEVICE_TREE_TRAMP, tramp, 8 /* plz no ldr.w */);
    WRITE32(UPDATE_DEVICE_TREE_HOOK_ADDR, UPDATE_DEVICE_TREE_HOOK_PATCH);

    /* clear caches to make the changes effective */
    arm_clean_caches();
}

#define NVRAM_DATA_LEN  (0x2000)

int UpdateDeviceTree__hook() {
    UpdateDeviceTree();

    void *chosen = NULL;
    if (!FindNode(0, "chosen", &chosen)) {
        printf("%s: failed to find the /chosen node\n", __func__);
        return -1;
    }

    /* populate nvram-proxy-data as iOS 5 iBoot doesn't do it */
    char *propName = "nvram-proxy-data";
    uint32_t propSize = 0;
    void *propData = NULL;

    if (!FindProperty(chosen, &propName, &propData, &propSize)) {
        printf("%s: failed to find the \"%s\" node\n", __func__, propName);
        return -1;
    }

    if (propSize != NVRAM_DATA_LEN) {
        printf("%s: \"%s\" prop has unexpected length (0x%x)\n", __func__, propName, propSize);
        return -1;
    }

    /* this is to make sure the NAND read goes to a cacheline aligned buffer */
    void *nvram_tmp = memalign(NVRAM_DATA_LEN, CACHELINE_SIZE);
    if (!nvram_tmp) {
        printf("out of memory?!\n");
        return -1;
    }

    if (!nand_nvram_read(0, nvram_tmp, NVRAM_DATA_LEN)) {
        return -1;
    }

    memcpy(propData, nvram_tmp, NVRAM_DATA_LEN);

    free(nvram_tmp);

    printf("%s: populated \"%s\"\n", __func__, propName);

    /* same for random-seed */
    propName = "random-seed";
    propSize = 0;
    propData = NULL;

    if (!FindProperty(chosen, &propName, &propData, &propSize)) {
        printf("%s: failed to find the \"%s\" node\n", __func__, propName);
        return -1;
    }

    random_get_bytes(propData, propSize);

    printf("%s: populated \"%s\"\n", __func__, propName);

    return 0;
}

#define BOOT_DEVICE "nand0a"
#define MOUNT_POINT "/boot"
#define KERNEL_PATH "/System/Library/Caches/com.apple.kernelcaches/kernelcache"

static
int boot() {
    printf("mounting root filesystem\n");
    if (fs_mount(BOOT_DEVICE, "hfs", MOUNT_POINT) != 0) {
        printf("failed to mount?!\n");
        return -1;
    }

    void *addr = NULL;
    if (load_kernelcache_file(MOUNT_POINT KERNEL_PATH, &addr) != 0) {
        printf("failed to load kernelcache?!\n");
        return -1;
    }

    printf("booting Darwin...\n");
    return boot_darwin(addr, *(void **)BOOT_ARGS_STRUCT);
}

void heap_repair();

void start() {
    enter_critical_section();

    printf("============== stage2 start ==============\n");

    heap_repair();
    patches_apply();

    exit_critical_section();

    boot();

    printf("boot failed, rebooting into recovery mode!\n");

    env_set("auto-boot", "false", 1 /* persistent */);
    nvram_save();

    platform_reset(0);
}
