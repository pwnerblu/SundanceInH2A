#include <sys/types.h>
#include "funcs.h"

#define THUMB_BX_LR         (0x4770)
#define THUMB_MOV_R0_1      (0x2001)
#define THUMB_MOV_R0_0      (0x2000)
#define THUMB_STR_R0_R3     (0x6018)

#define READ32(_addr) \
    *(volatile uint32_t *)(_addr)

#define WRITE32(_addr, _val) \
    *(volatile uint32_t *)(_addr) = _val

#define WRITE16(_addr, _val) \
    *(volatile uint16_t *)(_addr) = _val

static
size_t _strlen(const char *str) {
    const char *curr = str;
    while (*curr) {
        curr++;
    }
    return curr - str;
}

__attribute__((naked))
void UpdateDeviceTree_tramp() {
    asm("ldr r0, 1f");
    asm("bx  r0");
    asm("1:");
    asm(".long _UpdateDeviceTree__hook");
}

static
void patches_apply() {
    /* patch Image3 signature checks */
    WRITE16(IMAGE3_PATCH, THUMB_MOV_R0_0);
    WRITE16(IMAGE3_PATCH + 2, THUMB_STR_R0_R3);

    /* debug-enabled patch */
    WRITE16(DEBUG_ENABLED_PATCH_ADDR1, THUMB_MOV_R0_1);
    WRITE16(DEBUG_ENABLED_PATCH_ADDR2, THUMB_MOV_R0_1);

    /* point boot args string to a new location */
    WRITE32(BOOT_ARGS_PATCH_ADDR1, BOOT_ARGS_NEW_ADDR);
    WRITE32(BOOT_ARGS_PATCH_ADDR2, BOOT_ARGS_NEW_ADDR);

    /* populate them from the env var */
    const char *boot_args = env_get("boot-args");
    if (!boot_args) {
        boot_args = "";
    }

    size_t boot_args_len = _strlen(boot_args);
    memcpy((void *)BOOT_ARGS_NEW_ADDR, boot_args, boot_args_len + 1);

    /* add "amfi=0xff" boot-arg if not already there */
    const char *amfi_arg = " amfi=0xff";
    if (boot_args_len == 0) {
        /* get rid of the space if boot-args string is empty */
        amfi_arg++;
    }

    if (!contains_boot_arg((const char *)BOOT_ARGS_NEW_ADDR, "amfi=", true)) {
        strlcat((char *)BOOT_ARGS_NEW_ADDR, amfi_arg, 512);
    }

    /* 
     * add "launchctl_enforce_codesign=0" boot-arg if not already there,
     * it disables signed LaunchDaemons cache on iOS 6.1.x,
     * and should be no-op on 6.0.x
     */
    const char *launchctl_arg = " launchctl_enforce_codesign=0";
    if (!contains_boot_arg((const char *)BOOT_ARGS_NEW_ADDR, "launchctl_enforce_codesign=", true)) {
        strlcat((char *)BOOT_ARGS_NEW_ADDR, launchctl_arg, 512);
    }

    /* apply UpdateDeviceTree hook */
    void *tramp = (void *)((uintptr_t)UpdateDeviceTree_tramp & ~1); // clear the Thumb bit
    memcpy((void *)UPDATE_DEVICE_TREE_TRAMP, tramp, 8 /* plz no ldr.w */);
    WRITE32(UPDATE_DEVICE_TREE_HOOK_ADDR, UPDATE_DEVICE_TREE_HOOK_PATCH);

#ifdef RADIO_STATUS_VAR
    /* disable baseband (hopefully) */
    if (READ32(RADIO_STATUS_VAR) == 0x10) {
        printf("baseband not present\n");
    } else {
        printf("disabling baseband\n");
        WRITE32(RADIO_STATUS_VAR, 0x10);

        printf("enabling hactivation\n");
        strlcat((char *)BOOT_ARGS_NEW_ADDR, " -hactivate", 512);
    }
#endif

    /* clear caches to make the changes effective */
    arm_clean_caches();
}

#define NVRAM_DATA_LEN  (0x2000)

#if BOOT_FROM_NOR

/* nothing here was stolen from anywhere, totally not */

typedef uint32_t block_addr;

struct blockdev {
    struct blockdev *next;
    uint32_t flags;

    uint32_t block_size;
    uint32_t block_count;

    uint32_t block_shift;
    uint32_t total_len;
    uint32_t total_len_hi;

    int (*read_hook)(struct blockdev *, void *ptr, off_t offset, uint64_t len);
    int (*read_block_hook)(struct blockdev *, void *ptr, block_addr block, uint32_t count);
    int (*write_hook)(struct blockdev *, const void *ptr, off_t offset, uint64_t len);
    int (*write_block_hook)(struct blockdev *, const void *ptr, block_addr block, uint32_t count);
    int (*erase_hook)(struct blockdev *, off_t offset, uint64_t len);

    char name[16];
};

struct chrp_nvram_header {
    uint8_t sig;
    uint8_t cksum;
    uint16_t len;
    char    name[12];
    uint8_t data[0];
};

struct apple_nvram_header {
    struct chrp_nvram_header chrp;
    uint32_t adler;
    uint32_t generation;
    uint8_t padding[8];
};

static
uint8_t chrp_checksum(const struct chrp_nvram_header *hdr) {
    uint16_t sum;
    const uint8_t *p;

    sum = hdr->sig;
    for (p = (const uint8_t *)&hdr->len; p < hdr->data; p++) {
        sum += *p;
    }
    while (sum > 0xff) {
        sum = (sum & 0xff) + (sum >> 8);
    }

    return sum;
}

static const
uint32_t nor_nvram_offsets[] = {0xFC000, 0xFE000};

static int nvram_read(void *dst) {
    int read = -1;

    struct blockdev *nor = lookup_blockdev("nor0");

    struct apple_nvram_header *nvram = memalign(NVRAM_DATA_LEN, CACHELINE_SIZE);

    uint32_t max_gen = 0;
    uint32_t max_gen_idx = 0;

    for (int i = 0; i < 2; i++) {
        /* read NVRAM chunk header */
        read = nor->read_hook(nor, nvram, nor_nvram_offsets[i], nor->block_size);
        if (read != nor->block_size) {
            printf("NVRAM NOR read failed @ 0x%x\n", nor_nvram_offsets[i]);
            return -1;
        }

        /* check header checksum */
        if (chrp_checksum(&nvram->chrp) != nvram->chrp.cksum) {
            continue;
        }

        /* we want chunk with newest generation */
        if (nvram->generation > max_gen) {
            max_gen = nvram->generation;
            max_gen_idx = i;
        }
    }

    if (max_gen == 0) {
        return -1;
    }

    /* read selected chunk */
    read = nor->read_hook(nor, nvram, nor_nvram_offsets[max_gen_idx], NVRAM_DATA_LEN);
    if (read != NVRAM_DATA_LEN) {
        printf("NVRAM NOR read failed @ 0x%x\n", nor_nvram_offsets[max_gen_idx]);
        return -1;
    }

    /* copy to the caller */
    memcpy(dst, nvram, NVRAM_DATA_LEN);

    printf("selected NVRAM chunk @ 0x%x (gen 0x%x)\n",
        nor_nvram_offsets[max_gen_idx], nvram->generation);

    free(nvram);

    return 0;
}

#else

static int nvram_read(void *dst) {
    /* this is to make sure the NAND read goes to a cacheline aligned buffer */
    void *nvram_tmp = memalign(NVRAM_DATA_LEN, CACHELINE_SIZE);

    if (!nand_nvram_read(0, nvram_tmp, NVRAM_DATA_LEN)) {
        free(nvram_tmp);
        return -1;
    }

    memcpy(dst, nvram_tmp, NVRAM_DATA_LEN);
    free(nvram_tmp);

    return 0;
}

#endif

int UpdateDeviceTree__hook() {
    UpdateDeviceTree();

    void *chosen = NULL;
    if (!FindNode(0, "chosen", &chosen)) {
        printf("%s: failed to find the /chosen node\n", __func__);
        return -1;
    }

    char *propName = NULL;
    uint32_t propSize = 0;
    void *propData = NULL;

    /* populate nvram-proxy-data as iOS 5 iBoot doesn't do it */
    propName = "nvram-proxy-data";
    propSize = 0;
    propData = NULL;

    if (!FindProperty(chosen, &propName, &propData, &propSize)) {
        printf("%s: failed to find the \"%s\" node\n", __func__, propName);
        return -1;
    }

    if (propSize != NVRAM_DATA_LEN) {
        printf("%s: \"%s\" prop has unexpected length (0x%x)\n", __func__, propName, propSize);
        return -1;
    }

    if (nvram_read(propData) != 0) {
        printf("%s: failed to read NVRAM?!\n", __func__);
        return -1;
    }

    printf("%s: populated \"%s\"\n", __func__, propName);

    /* same for random-seed */
    propName = "random-seed";
    propSize = 0;
    propData = NULL;

    if (!FindProperty(chosen, &propName, &propData, &propSize)) {
        printf("%s: failed to find the \"%s\" node\n", __func__, propName);
        return -1;
    }

    random_get_bytes(propData, propSize);

    printf("%s: populated \"%s\"\n", __func__, propName);

    return 0;
}

#define BOOT_DEVICE "nand0a"
#define MOUNT_POINT "/boot"
#define KERNEL_PATH "/System/Library/Caches/com.apple.kernelcaches/kernelcache"

static
int boot() {
    printf("mounting root filesystem\n");
    if (fs_mount(BOOT_DEVICE, "hfs", MOUNT_POINT) != 0) {
        printf("failed to mount?!\n");
        return -1;
    }

    void *addr = NULL;
    if (load_kernelcache_file(MOUNT_POINT KERNEL_PATH, &addr) != 0) {
        printf("failed to load kernelcache?!\n");
        return -1;
    }

    printf("booting Darwin...\n");
    return boot_darwin(addr, *(void **)BOOT_ARGS_STRUCT);
}

void heap_repair();

void start() {
    enter_critical_section();

    printf("============== stage2 start ==============\n");

    heap_repair();
    patches_apply();

    exit_critical_section();

    boot();

    printf("boot failed, rebooting into recovery mode!\n");

    env_set("auto-boot", "false", 1 /* persistent */);
    nvram_save();

    platform_reset(0);
}
